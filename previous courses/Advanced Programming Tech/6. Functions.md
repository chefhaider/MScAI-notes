Here are explanations and syntax code examples for each definition provided in Lecture 6: Functions from the sources:

- **function prototype (Synonym for function declaration):** A function prototype, also known as a function declaration, specifies the **name of the function**, its **return type**, and the **parameter list** (the number and types of arguments the function expects). The prototype must be declared before the point where the function is called. It informs the compiler about the function's interface, allowing for type checking during compilation.
    
    ```
    // Function prototype (declaration)
    int add(int a, int b);
    ```
    
- **call operator:** The call operator is the pair of **parentheses `()`** used to execute a function. It takes two operands: the **name of the function** to be called and a **(possibly empty) comma-separated list of arguments** that are passed to the function.
    
    ```
    int add(int a, int b) {
        return a + b;
    }
    
    int main() {
        int sum = add(5, 3); // 'add(5, 3)' uses the call operator
        return 0;
    }
    ```
    
- **Parameters vs arguments:** **Parameters** are the variables listed in the function definition's parameter list. They act as placeholders for the values that will be passed to the function when it is called. **Arguments** are the actual values that are passed to the function when it is invoked (using the call operator). The value of the argument is used to initialise the corresponding parameter.
    
    ```
    // 'a' and 'b' are parameters in the function definition
    int multiply(int a, int b) {
        return a * b;
    }
    
    int main() {
        int x = 10;
        int y = 2;
        int product = multiply(x, y); // 'x' and 'y' are arguments passed to the function
        return 0;
    }
    ```
    
- **Header:** A header is a mechanism for making **class definitions and other declarations** (like function prototypes) available in multiple source files. Headers are for **declarations**, not definitions. By including a header file, you can use the declared entities in your current source file.
    
    ```
    // my_functions.h (header file)
    #ifndef MY_FUNCTIONS_H
    #define MY_FUNCTIONS_H
    
    int add(int a, int b); // Function declaration
    
    #endif
    ```
    
    ```
    // main.cpp (source file)
    #include "my_functions.h" // Including the header file
    
    int add(int a, int b) { // Function definition (typically in a .cpp file)
        return a + b;
    }
    
    int main() {
        int result = add(10, 5);
        return 0;
    }
    ```
    
- **header guard:** A header guard is a **preprocessor variable** defined within a header file to **prevent the header from being included more than once** in a single source file. This avoids redefinitions and potential compilation errors. The common structure involves `#ifndef`, `#define`, and `#endif` directives.
    
    ```
    // my_class.h
    #ifndef MY_CLASS_H // If MY_CLASS_H is not defined
    #define MY_CLASS_H // Define MY_CLASS_H
    
    class MyClass {
    public:
        void someMethod();
    };
    
    #endif // End of the ifndef block
    ```
    
- **inline function:** An inline function is a function for which the compiler may **replace the call to the function with the actual code of the function** at the point of call, if possible. This is a request to the compiler to avoid the normal function-calling overhead. Inline functions should often be defined in header files so the compiler has access to the function's code during compilation. The `inline` specification is only a request.
    
    ```
    // my_inline_functions.h
    #ifndef MY_INLINE_FUNCTIONS_H
    #define MY_INLINE_FUNCTIONS_H
    
    inline int square(int x) { // Inline function definition
        return x * x;
    }
    
    #endif
    ```
    
    ```
    // main.cpp
    #include "my_inline_functions.h"
    
    int main() {
        int result = square(5); // The compiler might replace this with '5 * 5'
        return 0;
    }
    ```
    
- **this pointer:** The `this` pointer is an **implicit parameter** of a **member function** (a function within a class). It **points to the object** on which the member function is invoked. It is a pointer to the class type.
    
    ```
    class Rectangle {
    private:
        int width;
        int height;
    public:
        Rectangle(int w, int h) : width(w), height(h) {}
    
        int area() const {
            return this->width * this->height; // Using the 'this' pointer (optional here)
        }
    
        void printDetails() const {
            std::cout << "Width: " << this->width << ", Height: " << this->height << std::endl;
        }
    };
    
    int main() {
        Rectangle rect(10, 5);
        rect.printDetails(); // 'this' in printDetails() points to the 'rect' object
        return 0;
    }
    ```
    
- **const member function:** A const member function is a member function of a class that **may be called for const objects of that type**. These functions **may not change the data members of the object** on which they operate. The `const` keyword is placed after the function's parameter list in the declaration and definition.
    
    ```
    class Circle {
    private:
        double radius;
    public:
        Circle(double r) : radius(r) {}
    
        double getRadius() const { // This is a const member function
            return radius; // Cannot modify 'radius' here
        }
    };
    
    int main() {
        const Circle c(7.0);
        double r = c.getRadius(); // Calling a const member function on a const object
        return 0;
    }
    ```
    
- **overloaded function:** An overloaded function is a function that has the **same name** as at least one other function in the same scope. Overloaded functions **must differ in the number or type of their parameters**. The main function cannot be overloaded.
    
    ```
    void print(int value) {
        std::cout << "Integer: " << value << std::endl;
    }
    
    void print(double value) {
        std::cout << "Double: " << value << std::endl;
    }
    
    int main() {
        print(10);    // Calls the version taking an int
        print(3.14); // Calls the version taking a double
        return 0;
    }
    ```
    
- **function matching (overload resolution):** Function matching, also known as overload resolution, is the **compiler process by which a call to an overloaded function is resolved**. The compiler compares the **arguments used in the call** to the **parameter list of each overloaded function** to find the best match. Name lookup happens before type checking during compilation.
    
    _(No direct syntax code example specifically for the process itself, the overloaded function example above demonstrates a scenario where overload resolution occurs.)_
    
- **candidate functions:** Candidate functions are the **set of functions** that are considered by the compiler when resolving a function call. These are all functions with the **same name** as the one used in the call for which a declaration is in scope at the time of the call.
    
    _(Consider the overloaded `print` function example above. When `print(10)` is called, both `void print(int value)` and `void print(double value)` are candidate functions because they have the same name and are in scope.)_
    
- **viable functions:** Viable functions are a **subset of the candidate functions** that could potentially match a given function call. For a function to be viable, it must have the **same number of parameters as arguments** in the call, and each **argument type must be potentially convertible to the corresponding parameter type**. Default arguments are considered during this stage.
    
    _(In the `print(10)` call example, both candidate `print` functions are also viable because an `int` argument can be exactly matched with the `int` parameter and can be promoted to a `double` for the other version.)_
    
- **ambiguous call:** An ambiguous call is a **compile-time error** that occurs when the compiler **cannot find a single best match** for a call to an overloaded function. This happens when multiple viable functions provide an equally good match for the given arguments.
    
    ```
    void process(int a, double b) {
        std::cout << "process(int, double)" << std::endl;
    }
    
    void process(double a, int b) {
        std::cout << "process(double, int)" << std::endl;
    }
    
    int main() {
        // process(5, 5); // This would be an ambiguous call because int can be promoted to double and vice versa
        return 0;
    }
    ```
    
- **best match:** The best match is the **single function** from the set of viable overloaded functions that has the **best match** for the arguments of a given call. The compiler ranks the implicit argument-type conversions to determine the best match. Exact match is better than promotion, which is better than standard conversions, and so on.
    
    _(In the `print(10)` example, `void print(int value)` is the best match because it's an exact match, which is preferred over the conversion of `int` to `double` in `void print(double value)`.)_
    
- **automatic objects:** Automatic objects are objects that are **local to a function**. They are **created and initialised anew on each call** to the function and are **destroyed at the end of the block** in which they are defined. Parameters are also examples of automatic objects. They no longer exist once the function terminates.
    
    ```
    void exampleFunction() {
        int localVariable = 10; // localVariable is an automatic object
        std::cout << "Inside function: " << localVariable << std::endl;
    }
    
    int main() {
        exampleFunction();
        // localVariable no longer exists here
        return 0;
    }
    ```
    
- **temporary (object):** A temporary object is an **unnamed object** that is **automatically created by the compiler** when evaluating an expression. A temporary persists until the **end of the largest expression** that encloses the expression for which it was created.
    
    ```
    #include <string>
    
    std::string getFullName(const std::string& first, const std::string& last) {
        return first + " " + last; // A temporary std::string object might be created here
    }
    
    int main() {
        std::string name = getFullName("John", "Doe"); // The result of the concatenation is a temporary
        std::cout << name << std::endl;
        return 0;
    }
    ```
    
- **local static objects:** Local static objects are objects that are **local to a function** but are declared with the `static` keyword. They are **guaranteed to be initialised no later than the first time** that program execution passes through the objectâ€™s definition. Unlike automatic objects, they are **not destroyed until the program terminates**. This means they retain their value between function calls.
    
    ```
    #include <iostream>
    
    size_t count() {
        static size_t counter = 0; // counter is a local static object
        return ++counter;
    }
    
    int main() {
        std::cout << "Count: " << count() << std::endl; // Output: Count: 1
        std::cout << "Count: " << count() << std::endl; // Output: Count: 2
        std::cout << "Count: " << count() << std::endl; // Output: Count: 3
        return 0;
    }
    ```
    
- **object lifetime:** Object lifetime refers to the period during which an object exists in memory.
    
    - Objects defined inside a block (like automatic objects) exist from their definition until the end of the block.
    - Local static objects and global objects exist from program startup until the `main` function ends.
    - Dynamically created objects (using `new`) exist until the memory is explicitly freed using `delete`.
    
    _(The examples above for automatic, local static, and temporary objects illustrate different aspects of object lifetime. Dynamic object lifetime is not directly defined within the "Functions" section but is related to the broader concept of object management in C++.)_