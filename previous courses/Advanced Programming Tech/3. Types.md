 

# code examples



### Literal Constants

A **literal constant** is a fixed value such as a number, a character, or a string of characters; its value cannot be changed.

- **Integer Literals**: Examples include `20`, `024` (octal), and `0x14` (hexadecimal). You can specify an unsigned integer with a `u` suffix (e.g., `128u`) and a long integer with an `L` suffix (e.g., `1L`). The source notes that you can even assign a negative number to an unsigned type.
    
    ```
    int decimalInt = 20;
    int octalInt = 024;
    int hexInt = 0x14;
    unsigned int unsignedInt = 128u;
    long longInt = 1L;
    unsigned int negativeToUnsigned = -5; // Implementation-defined behavior
    ```
    
- **Floating-Point Literals**: Examples include `0.`, `0e0`, `.001f`, and `1E-3F`. The source poses the question about the type of the constants `1` and `1.0`. `1` is typically an `int`, while `1.0` is typically a `double`. The `f` or `F` suffix indicates a `float` literal.
    
    ```
    double doubleVal1 = 0.;
    double doubleVal2 = 0e0;
    float floatVal1 = .001f;
    float floatVal2 = 1E-3F;
    double doubleByDefault = 1.0;
    int intType = 1;
    ```
    
- **Boolean and Literals**: Boolean literals are `true` and `false`.
    
    ```
    bool isTrue = true;
    bool isFalse = false;
    ```
    
- **Character**: Character literals are enclosed in single quotes, such as `'a'`.
    
    ```
    char charVar = 'a';
    ```
    
- **String**: String literals are enclosed in double quotes, such as `"a"`.
    
    ```
    std::string stringVar = "a";
    ```
    

### Escape Sequences

An **escape sequence** is an alternative way to represent characters, often used for nonprintable characters like newline (`\n`) or tab (`\t`). An escape sequence consists of a backslash (`\`) followed by a character, a three-digit octal number, or a hexadecimal number. They can be used within single quotes for character literals or double quotes for string literals. Examples given are `\n`, `\t`, `\\` (backslash itself), and `\b` (backspace).

```
char newlineChar = '\n';
std::string stringWithTab = "Hello\tWorld";
std::string stringWithBackslash = "Path: C:\\folder";
```

### Variables

An **object** is a region of memory that has a type, and a **variable** is an object that has a name.

- **Declaration**: A **declaration** asserts the existence of a variable, function, or type defined elsewhere in the program. Some declarations are also definitions.
    
    ```
    extern int globalVar; // Declaration of a global variable defined elsewhere
    ```
    
- **Definition**: A **definition** allocates storage for a variable of a specified type and can optionally initialize it. Names (identifiers) cannot be used until they are defined or declared.
    
    ```
    int localVar; // Definition of a local variable
    int initializedVar = 10; // Definition and initialization
    ```
    
- **Type specifier**: A **type specifier** is part of a definition or declaration that names the type of the variables that follow (e.g., `int`, `double`, `std::string`).
    
- **Identifier**: An **identifier** is a name, which must be a nonempty sequence of letters, digits, and underscores and cannot begin with a digit. Identifiers are **case-sensitive** (uppercase and lowercase letters are distinct) and cannot use C++ **keywords**.
    
    ```
    int count;
    int numberOfItems;
    int _value;
    // int 1stValue; // Invalid: cannot start with a digit
    int Value; // Distinct from value due to case sensitivity
    // int class; // Invalid: class is a keyword
    ```
    

### Type-checking

**Statically typed** languages like C++ perform **compile-time type checking**. **Type-checking** is the process by which the compiler verifies that the way objects of a given type are used is consistent with the definition of that type. This helps catch type errors before the program runs.

```
int num = 10;
// bool result = num + "hello"; // Compile-time error: cannot add int and string
```

### Variable Initialization

**Variable initialization** refers to the rules for initializing variables and array elements when no explicit initializer is given.

- For **class types**, objects are initialized by running the class's **default constructor**. If there is no default constructor, a compile-time error occurs unless an explicit initializer is provided.
    
    ```
    #include <string>
    std::string s; // Calls the default constructor of std::string
    // class MyClass { public: MyClass(int) {} };
    // MyClass obj; // Error: no default constructor
    // MyClass obj(5); // Correct: explicit initializer
    ```
    
- For **built-in types**, initialization depends on **scope**. Objects defined at **global scope** are initialized to **0**. Objects defined at **local scope** are **uninitialized** and have **undefined values**.
    
    ```
    int globalVar; // Initialized to 0
    int main() {
        int localVar; // Uninitialized, undefined value
        int initializedLocal = 5; // Explicitly initialized
        return 0;
    }
    ```
    

### Scope

**Scope** is a portion of a program in which names have meaning. C++ has several levels of scope:

- **global**: Names defined outside any other scope.
- **class**: Names defined by a class.
- **namespace**: Names defined within a namespace.
- **local**: Names defined within a function.
- **block**: Names defined within a block of statements (within curly braces `{}`).
- **statement**: Names defined within the condition of a statement (e.g., `if`, `for`, `while`).

Scopes **nest**. Names declared at global scope are accessible in function and statement scope.

```
std::string s1 = "hello"; // global scope

int main() {
    std::string s2 = "world"; // local scope (of main)
    std::cout << s1 << " " << s2 << std::endl;
    int s1 = 42; // local scope (within main), hides the global s1
    std::cout << s1 << " " <<  s2 << std::endl;
    if (true) {
        int blockVar = 100; // block scope
        std::cout << blockVar << std::endl;
    }
    // std::cout << blockVar << std::endl; // Error: blockVar is not in scope here
    return 0;
}
```

### Pointers I & II

A **pointer** is an object that holds the address of another object. Example: `int * p;` declares a pointer `p` that can hold the address of an `int`.

Values that can be used to initialize or assign to a pointer include:

- A constant expression with the value `0` or better `nullptr`.
- The address of an object of an appropriate type (using the **address-of operator** `&`).
- The address one past the end of another object.
- Another valid pointer of the same type.

**`void*`** is a pointer type that can point to any non-const type. However, only limited operations are permitted on `void*` pointers: they can be passed or returned from functions and compared with other pointers. They **may not be dereferenced**.

```
int x = 10;
int *ptr1 = &x; // ptr1 holds the address of x
int *ptr2 = nullptr; // ptr2 is a null pointer
void *voidPtr = &x; // voidPtr points to x
// *voidPtr = 20; // Error: void* cannot be dereferenced
```

Pointers are also considered **iterators for arrays**.

The **`*` operator** is used for **dereferencing** a pointer, which yields the object to which the pointer points. Assigning to the result of a dereference assigns a new value to the underlying object.

```
int y = 5;
int *ptrY = &y;
std::cout << *ptrY << std::endl; // Output: 5
*ptrY = 15;
std::cout << y << std::endl; // Output: 15
```

The **`&` operator** is the **address-of operator**, which yields the memory address of the object it is applied to.

### Memory region

Memory is a linear address space. C/C++ provides the power (and responsibility) to access arbitrary memory regions. The operating system (OS) prevents access to certain protected memory regions, which can lead to a segmentation fault (SEGFAULT). Pointers store memory addresses.

The source briefly mentions the **Stack** and the **Heap**. The heap is a region of memory where dynamic memory allocation occurs, often using `new`.

**Memory Leaks** occur when memory that is no longer needed is not released. The provided example shows a memory leak where memory is allocated using `new int` and the pointer `arr` is then set to `0` (or goes out of scope without being deleted), resulting in the allocated memory being inaccessible but not freed. The corrected example shows how to release the dynamically allocated memory using `delete [] arr`.

```
int main() {
    int *arr1 = new int; // Allocate memory on the heap
    // arr1 = 0; // Memory leak! The allocated memory is no longer accessible
    delete [] arr1; // Correct way to release the memory
    return 0;
}
```

### Pointers and the const qualifier

The `const` qualifier can interact with pointers in several ways:

- **Pointers to const objects**: You cannot modify the value of the object pointed to by a pointer to const.
    
    ```
    const double pi = 3.14;
    const double* cptr = &pi;
    // *cptr = 42; // Error: cannot assign to a const object through a const pointer
    double nonConst = 2.71;
    cptr = &nonConst; // OK: a pointer to const can point to a non-const object
    // *cptr = 5.0; // Error: still cannot modify through this pointer
    ```
    
- **Pointers that think they are const**: This is essentially the same as a pointer to a const object; the pointer itself is not const, but it treats the object it points to as const.
    
- **Const pointers**: The pointer itself cannot be changed to point to a different memory location, but the value of the object it points to can be modified (if the object is not const).
    
    ```
    int ierr = 0;
    int *const curErr = &ierr;
    *curErr = 1; // OK: modifies the object pointed to
    // curErr = &pi; // Error: cannot change where curErr points
    ```
    
- **Const pointers to const objects**: Neither the pointer nor the object it points to can be changed.
    
    ```
    const double pi = 3.14;
    const double* const pi_ptr = &pi;
    // *pi_ptr = 42; // Error: cannot modify the object
    // pi_ptr = &nonConst; // Error: cannot change where the pointer points
    ```
    

### References

A **reference** is an alias for another object. It is defined as `type &id = object;`, where `id` becomes another name for `object`. Any operation on the reference is translated to an operation on the original object.

- Once a reference is created, there is **no way to rebind** it to a different object.
- A **non-const reference** may only be attached to an object of the **same type** as the reference itself.
- A **const reference** can be bound to a const object, a non-const object, or the result of an expression.
- A const reference **may not change the object to which it refers**.

```
int i = 10;
int &ref_i = i; // ref_i is now an alias for i
std::cout << i << " " << ref_i << std::endl; // Output: 10 10
ref_i = 20;
std::cout << i << " " << ref_i << std::endl; // Output: 20 20

const int const_j = 5;
const int &cref_j = const_j;
const int &cref_expr = 5 + 2;

int nonConst_k = 15;
const int &cref_k = nonConst_k;
// int &nonConstRef = const_j; // Error: cannot bind non-const reference to a const object
```

### Pointers vs. references

The source compares pointers and references:

- **References always refer to an object**. Pointers can be null or uninitialized.
- **Assigning to a reference changes the underlying object**. Assigning to a pointer changes the address it holds.

```
int i = 1, j = 2;
int *pi = &i, *pj = &j;
pi = pj; // pi now points to the same object as pj (j)
std::cout << *pi << " " << *pj << std::endl; // Output: 2 2

int &ri = i, &rj = j;
ri = rj; // The value of i is changed to the value of j (i becomes 2)
std::cout << i << " " << j << " " << ri << " " << rj << std::endl; // Output: 2 2 2 2
```

### Typedef

**`typedef`** introduces a synonym for another type. The form is `typedef type synonym;`, which defines `synonym` as another name for `type`. C++11 provides an alternative using declaration: `using synonym = type;`. Purposes include:

- Hiding the implementation of a given type and emphasizing its purpose.
- Streamlining complex type definitions.
- Allowing a single type to be used for more than one purpose while making the purpose clear.

```
typedef int count_t; // count_t is now a synonym for int
using size_t = unsigned int; // size_t is now a synonym for unsigned int

count_t item_count = 10;
size_t data_size = 1024;
```

### decltype

**`decltype`** is a type specifier that deduces the type of a variable or an expression. Example: `const int ci = 0; decltype(ci) x = 0;` // `x` has type `const int`.

```
const int ci = 0;
decltype(ci) x = 0; // x is of type const int
// x = 1; // Error: cannot assign to variable with const-qualified type 'const int'

int i = 5;
decltype(i) y = 10; // y is of type int
```

### auto

**`auto`** is a type specifier that deduces the type of a variable from its initializer. Example: `auto i = 10;` // `i` is an `int`.

```
auto a = 10; // a is an int
auto b = 3.14; // b is a double
auto c = "hello"; // c is a const char*
auto d = std::string("world"); // d is a std::string
```

### Moving objects

A major feature in newer C++ standards is the ability to **move** rather than **copy** an object, which can provide a significant performance boost. To support move operations, a new kind of reference, an **rvalue reference**, is introduced.

### Rvalue reference

**Rvalue references** refer to objects that are about to be destroyed (temporary objects). While **lvalues** have persistent state, **rvalues** are either literals or temporary objects created during the evaluation of expressions. Note that **variables are lvalues** even if their type is an rvalue reference. Example: `int i = 42; int &&rr = i * 42;`.

```
int i = 42;
int &lr = i; // lvalue reference
int &&rr = i * 42; // rr is an rvalue reference to a temporary object

// int &&rr2 = i; // Error: cannot bind rvalue reference to an lvalue
int temp = i * 42;
int &&rr2 = std::move(i); // Can bind using std::move, but i's state is now unspecified
```

### Expression category taxonomy

The source briefly describes different categories of expressions:

- **lvalue**: An expression that yields an object or function. A non-const lvalue that denotes an object may be the left-hand operand of assignment.
- **xvalue**: An “eXpiring” value, usually referring to an object near the end of its lifetime (so that its resources may be moved). Certain expressions involving rvalue references yield xvalues.
- **prvalue**: A “pure” rvalue that is not an xvalue (e.g., literals, results of certain operator expressions).
- **glvalue**: A “generalized” lvalue, encompassing both lvalues and xvalues.
- **rvalue**: An expression that yields a value but not necessarily an associated location; it is either an xvalue or a prvalue (a temporary object).

The source provides examples categorizing different expressions as lvalues, prvalues, or xvalues.

```
int var; // var is an lvalue
var = 10; // 10 is a prvalue
int* ptr = &var; // &var is an lvalue
*ptr = 20; // *ptr is an lvalue

float&& tempFunc() { return 2.0f; } // The call to tempFunc() is an xvalue
float plainFunc() { return 2.0f; } // The call to plainFunc() is a prvalue
```
---
# definitions

- **Literal Constants**:
    - A literal constant is a value that cannot be changed, such as a number, character, or string.
    - Literal characters are enclosed in single quotes, while literal strings are in double quotes.
    - Integer Literals: Examples include 20, 024, and 0x14.
        - `unsigned`: 128u
        - `long`: 1L (assigning a negative number to unsigned is possible)
    - Floating-Point Literals: Examples include 0., 0e0, .001f, and 1E-3F.
        - It raises the question of what the types are of constants 1 and 1.0.
    - Boolean and Literals
        - `Bool`: `true`, `false`
        - Character: ´a´
        - String: “a“
- **Escape Sequences**:
    - Represent non-printable characters like newline or tab.
    - Consist of a backslash followed by a character, a three-digit octal number, or a hexadecimal number.
    - Can be used as a literal character (single quotes) or in a literal string (double quotes).
    - Examples: `\n`, `\t`, `\\`, `\b`
- **Variables**:
    - **Object**: A region of memory that has a type. A variable is an object that has a name.
    - **Declaration**: Asserts the existence of a variable, function, or type defined elsewhere in the program.
        - Some declarations are also definitions, but only definitions allocate storage for variables.
    - **Definition**: Allocates storage for a variable of a specified type and optionally initialises the variable.
        - Names cannot be used until they are defined or declared.
    - **Type specifier**: Part of a definition or declaration that names the type of the variables that follow.
    - **Identifier**: A name which is a non-empty sequence of letters, digits, and underscores, but it must not begin with a digit.
- **Scope**:
    - A portion of a program in which names have meaning.
    - Several levels of scope exist in C++:
        - global—names defined outside any other scope.
        - class—names defined by a class.
        - namespace—names defined within a namespace.
        - local—names defined within a function.
        - block—names defined within a block of statements, that is, within a pair of curly braces.
        - statement—names defined within the condition of a statement, such as an if, for, or while.
    - Scopes nest, so names declared at global scope are accessible in function and statement scope.
- **Pointers**:
    - A pointer is an object that holds the address of another object.
    - Values used to initialise or assign to a pointer:
        - A constant expression with value 0 or better `nullptr`
        - An address of an object of an appropriate type
        - The address one past the end of another object
        - Another valid pointer of the same type
    - Pointers are iterators for arrays.
    - `void*`: A pointer type that can point to any non-const type.
        - Limited operations are permitted on `void*` pointers: They can be passed or returned from functions and they can be compared with other pointers.
        - They may not be dereferenced.
    - `*` operator: Dereferencing a pointer yields the object to which the pointer points. Assigning to the result of a dereference assigns a new value to the underlying object.
    - `&` operator: The address-of operator. Yields the address in memory to which it is applied.
- **Memory Region**:
    - Memory is a linear address space.
    - C/C++ provides the ability (and responsibility) to access arbitrary memory regions.
    - The OS prevents access to certain memory regions, resulting in a `SEGFAULT`.
    - Pointer store memory addresses.
    - Stack
    - Heap
        - `int * myArray = new int;`
    - Memory Leaks
        - Occur when memory is no longer needed but is not released.
- **References**:
    - Always refer to an object.
    - Assigning to a reference changes the underlying object.
- **Typedef**:
    - Introduces a synonym for some other type.
    - Form: `typedef type synonym;` defines synonym as another name for the specified type.
    - Alternative (C++11): `using synonym = type;`
    - Purposes:
        - Hide the implementation of a given type and emphasise the purpose for which the type is used.
        - Streamline complex type definitions, making them easier to understand.
        - Allow a single type to be used for more than one purpose while making the purpose clear each time the type is used.
- **Decltype**:
    - A type specifier that deduces the type of a variable or an expression.
    - Example:
        - `const int ci = 0;`
        - `decltype(ci) x = 0;` // x has type const int
- **Auto**:
    - A type specifier that deduces the type of a variable from its initialiser.
    - Example:
        - `auto i = 10;` // i is an int
- **Moving Objects**:
    - Moving instead of copying can provide a significant performance boost.
    - To support move operations, a new kind of reference is introduced: an rvalue reference.
    - Example is not available in the source.


