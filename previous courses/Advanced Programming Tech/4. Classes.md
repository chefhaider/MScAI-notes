Lecture 4 is about **classes** in C++ and covers the following key points:

- **Classes**:
    - A class in C++ is a mechanism for defining **abstract data types**.
    - Classes can contain **data**, **function**, or **type members**.
    - Classes are defined using the `class` or `struct` keyword.
    - A class defines a **new type** and a **new scope**.
- **Member Functions**:
    - A member function is a class member that is a function.
    - Ordinary member functions are bound to an object of the class type through the implicit `this` pointer.
    - Static member functions are not bound to an object and have no `this` pointer.
- **Access Specifiers**:
    - Access specifiers define whether the following members are accessible to users of the class or only to friends and members.
    - Each specifier sets the access protection for the members declared up to the next label.
    - Specifiers can appear multiple times within the class.
    - The access specifiers are `public`, `private`, and `protected`.
- **Data Abstraction and Encapsulation**:
    - **Abstract data type**: A data structure (like a class) using **encapsulation** to hide its implementation.
    - **Data abstraction**: A programming technique that focuses on the interface to a type.
        - Allows programmers to ignore the details of how a type is represented and to think instead about the operations that the type can perform.
    - **Encapsulation**: Separation of implementation from interface; encapsulation hides implementation details of a type.
        - In C++, encapsulation is enforced by preventing general user access to the private parts of a class.
        - Access specifiers enforce abstraction and encapsulation.
    - **Interface**: The operations supported by a type.
    - **Implementation**: The (usually private) members of a class that define the data and any operations that are not intended for use by code that uses the type.
- **Advantages of Abstraction and Encapsulation**:
    - Class internals are protected from inadvertent user-level errors, which might corrupt the state of the object.
    - The class implementation may evolve over time in response to changing requirements or bug reports without requiring changes in user-level code.
- **Class Definitions**:
    - **Incomplete type**: A type that has been declared (forward declaration) but not yet defined.
        - It is not possible to use an incomplete type to define a variable or class member.
        - It is legal to define references or pointers to incomplete types.
    - Use `typedefs`/`using` to streamline classes.
    - Use only a few (overloaded) member functions.
    - Prefer inlined member functions (even if it is only a hint to the compiler).
    - Class definitions end with a semicolon.
- **Const and Mutable Data Members**:
    - **Const member function**: A member function that may not change an object's ordinary (i.e., neither static nor mutable) data members.
        - The `this` pointer in a `const` member is a pointer to `const`.
        - A member function may be overloaded based on whether the function is `const`.
    - **Mutable data member**: A data member that is never `const`, even when it is a member of a `const` object.
        - A mutable member can be changed inside a `const` function.
- **Class Scope**:
    - Each class defines a scope.
    - Class scopes are more complicated than other scopes—member functions defined within the class body may use names that appear after the definition.
    - Two different classes have two different class scopes (even if they have the same member list).
    - Parameter lists and function bodies are in class scope.
    - Function return types are not always in class scope.
- **Name Lookup**:
    - The process by which the use of a name is matched to its corresponding declaration.
    - Class definitions are processed in two phases.
        - First, the member declarations are compiled.
        - Only after all the class members have been seen are the definitions themselves compiled.
- **Constructors**:
    - A special member function that is used to initialise newly created objects.
    - The job of a constructor is to ensure that the data members of an object have safe, sensible initial values.
    - Constructors are executed whenever new objects of a class type are created.
    - Constructors have the same name as the class and may not specify a return type.
    - Constructors may be overloaded.
    - Constructors may not be declared as `const`.
- **Constructor Initialiser List**:
    - Specifies initial values of the data members of a class.
    - The members are initialised to the values specified in the initialiser list before the body of the constructor executes.
- **Copy Constructor**:
    - A constructor that defines what happens when an object of a class is initialised from another object of the same type.
        - If a class does not define its own copy constructor, the compiler synthesizes one.
- **Synthesised Copy Constructor**:
    - The copy constructor created (synthesised) by the compiler for classes that do not explicitly define the copy constructor.
    - The synthesised copy constructor memberwise initialises the new object from the existing one.
    - **Memberwise Initialisation**: The constructor copies, member by member, from the old object to the new.
        - Members of built-in or compound type are copied directly.
        - Those that are of class type are copied by using the member's copy constructor.
    - To prevent copies, a class must explicitly declare its copy constructor as private.
- **Assignment Operator**:
    - The assignment operator can be overloaded to define what it means to assign one object of a class type to another of the same type.
    - The assignment operator must be a member of its class and should return a reference to its object.
    - The compiler synthesises the assignment operator if the class does not explicitly define one.
- **Destructor**:
    - A special member function that cleans up an object when the object goes out of scope or is deleted.
    - The compiler automatically destroys each member.
        - Members of class type are destroyed by invoking their destructor.
        - No explicit work is done to destroy members of built-in or compound type.
        - In particular, the object pointed to by a pointer member is not deleted by the automatic work done by the destructor.
- **Defining an Overloaded Operator**:
    - An overloaded operator is a function that redefines one of the C++ operators to operate on object(s) of class type.
    - Overloaded operators must have an operand of class type.
    - This rule enforces the requirement that an overloaded operator may not redefine the meaning of the operators when applied to objects of built-in types.
    - Precedence and associativity are fixed.
    - Short-circuit evaluation is not preserved.
    - Overloaded functions that are members of a class may appear to have one less parameter than the number of operands.
    - Operators that are members have an implicit `this` pointer that is bound to the first operand.
- **Overloaded Operator Design**:
    - Do not overload operators with built-in meanings.
    - It is usually not a good idea to overload the comma, address-of, logical AND, or logical OR operators.
    - If you nevertheless do so, the operators should behave analogously to the synthesised operators.
    - Classes that will be used as key type of an associative container should define the `<` and `==` operator.
    - In most cases then it is also a good idea to define the `>`, `<=`, `>=`, `!=` operators.
- **Assignment and Subscript Operators**:
    - Assignment operators can be overloaded.
    - Assignment and subscript operators must be class member functions.
    - Assignment should return a reference to `*this`.
    - In order to support the expected behaviour for nonconst and const objects, two versions of a subscript operator should be defined:
        - one that is a nonconst member and returns a reference
        - one that is a const member and returns a const reference
- **Member Access Operators**:
    - Operator arrow must be defined as a class member function.
    - The overloaded arrow operator must return either a pointer to a class type or an object of a class type.



----
Here are the definitions related to classes from Lecture 4, along with syntax code examples for each, as requested.

- **Class:** A C++ mechanism for defining own abstract data types. Classes may have data, function or type members. Classes are defined using either the `class` or `struct` keyword. A class defines a new type and a new scope.
    
    ```
    class MyClass {
    public:
        // public members (interface)
        int publicData;
        void publicFunction();
    private:
        // private members (implementation)
        int privateData;
        void privateFunction();
    };
    
    struct MyStruct {
        // members are public by default
        int data;
    };
    ```
    
- **Member function:** A class member that is a function.
    
    - **Ordinary member functions** are bound to an object of the class type through the implicit `this` pointer.
    - **Static member functions** are not bound to an object and have no `this` pointer.
    
    ```
    class MyClass {
    public:
        void ordinaryMemberFunction() {
            // 'this' implicitly points to the current object
            this->privateData = 10;
        }
    
        static void staticMemberFunction() {
            // No 'this' pointer available here
            staticData = 20;
        }
    private:
        int privateData;
        static int staticData;
    };
    
    int MyClass::staticData = 0; // Definition of the static member
    ```
    
- **Access specifier:** Defines if the following members are accessible to users of the class or only to friends and members. Each specifier sets the access protection for the members declared up to the next label. Specifiers may appear multiple times within the class. The available specifiers are `public`, `private`, or `protected`.
    
    ```
    class MyClass {
    public:
        int publicData; // Accessible from anywhere
    private:
        int privateData; // Accessible only from within the class and by friends
    protected:
        int protectedData; // Accessible from within the class, by friends, and by derived classes
    };
    ```
    
- **Abstract data type:** A data structure (like a class) using **encapsulation** to hide its implementation.
    
    ```
    // Example: Sales_item class (interface shown)
    class Sales_item {
    public:
        Sales_item(const std::string &book);
        Sales_item(std::istream &is);
        friend std::istream& operator>>(std::istream&, Sales_item&);
        friend std::ostream& operator<<(std::ostream&, const Sales_item&);
        Sales_item& operator+=(const Sales_item&);
        double avg_price() const;
        bool same_isbn(const Sales_item &rhs) const;
        Sales_item();
    private:
        std::string isbn;
        unsigned units_sold;
        double revenue;
    };
    ```
    
    This class provides an interface (public members) to interact with sales items without exposing the underlying data representation (private members).
    
- **Data abstraction:** A programming technique that focuses on the interface to a type. It allows programmers to ignore the details of how a type is represented and to think instead about the operations that the type can perform.
    
    ```
    // Using the Sales_item class, a programmer interacts through
    // constructors, operator+=, avg_price(), etc., without needing
    // to know how isbn, units_sold, and revenue are stored.
    Sales_item item1("978-0596809108");
    Sales_item item2("978-0596809108");
    item1 += item2;
    std::cout << item1.avg_price() << std::endl;
    ```
    
- **Encapsulation:** Separation of implementation from interface; encapsulation hides implementation details of a type. In C++, encapsulation is enforced by preventing general user access to the private parts of a class. Access specifiers enforce abstraction and encapsulation.
    
    ```
    class Counter {
    public:
        void increment() { ++count; }
        int getCount() const { return count; }
    private:
        int count = 0; // Implementation detail hidden from users
    };
    
    Counter c;
    c.increment();
    std::cout << c.getCount() << std::endl;
    // c.count = 10; // Error: private member is not accessible
    ```
    
- **Interface:** The operations supported by a type. In a well-designed class, the interface is defined in the public part of the class. Function members are part of the interface when they are operations that users of the type are expected to use.
    
    ```
    // In the Counter class above, increment() and getCount() form the public interface.
    ```
    
- **Implementation:** The (usually private) members of a class that define the data and any operations that are not intended for use by code that uses the type. Data members ordinarily are part of the implementation. Function members are part of the implementation when they perform operations needed by the class but not defined for general use.
    
    ```
    // In the Counter class, the private member 'int count' and any private helper
    // functions would be part of the implementation.
    ```
    
- **Incomplete type:** A type that has been declared (forward declaration) but not yet defined. It is not possible to use an incomplete type to define a variable or class member. It is legal to define references or pointers to incomplete types.
    
    ```
    class ForwardDeclaredClass; // Incomplete type
    
    ForwardDeclaredClass* ptr; // Legal: pointer to an incomplete type
    ForwardDeclaredClass& ref = *ptr; // Legal: reference to an incomplete type (if ptr points to a valid object later)
    // ForwardDeclaredClass obj; // Error: cannot define a variable of incomplete type
    
    class DefinedClass {
        // ForwardDeclaredClass member; // Error: cannot have a member of incomplete type
        ForwardDeclaredClass* memberPtr; // Legal: pointer to incomplete type
    };
    
    class ForwardDeclaredClass { // Definition completes the type
    public:
        int data;
    };
    ```
    
- **`const` member function:** A member function that may not change an object's ordinary (i.e., neither static nor mutable) data members. The `this` pointer in a `const` member is a pointer to `const`. A member function may be overloaded based on whether the function is `const`.
    
    ```
    class MyClass {
    public:
        int getData() const {
            // data = 10; // Error: cannot modify data in a const member function
            return data;
        }
        void setData(int val) {
            data = val;
        }
        int getData() { // Overloaded non-const version (less common)
            data += 1;
            return data;
        }
    private:
        int data;
    };
    ```
    
- **`mutable` data member:** A data member that is never `const`, even when it is a member of a `const` object. A `mutable` member can be changed inside a `const` function.
    
    ```
    class MyClass {
    public:
        int getData() const {
            accessCount++; // Legal: mutable member can be modified
            return data;
        }
        int getAccessCount() const { return accessCount; }
    private:
        int data;
        mutable int accessCount = 0;
    };
    
    const MyClass obj;
    obj.getData(); // accessCount will be incremented even though obj is const
    std::cout << obj.getAccessCount() << std::endl;
    ```
    
- **Class scope:** Each class defines a scope. Class scopes are more complicated than other scopes—member functions defined within the class body may use names that appear after the definition. Two different classes have two different class scopes (even if they have the same member list). Parameter lists and function bodies are in class scope. Function return types are not always in class scope.
    
    ```
    class MyClass {
    public:
        int getSum() const { return data + value; } // 'value' declared later is still in scope
    private:
        int data = 5;
        int value = 10;
    };
    
    class AnotherClass {
    public:
        int data = 20;
    };
    
    void someFunction() {
        MyClass mc;
        // int data = mc.data; // 'data' refers to MyClass::data
        AnotherClass ac;
        // int data = ac.data; // This 'data' is different from MyClass::data
    }
    ```
    
- **Name lookup:** The process by which the use of a name is matched to its corresponding declaration. Class definitions are processed in two phases: first, the member declarations are compiled; only after all the class members have been seen are the definitions themselves compiled.
    
    ```
    class MyClass {
    public:
        void func1() { func2(); } // func2 can be used even though its definition appears later
        void func2() { /* ... */ }
    };
    ```
    
- **Constructor:** A special member function that is used to initialize newly created objects. The job of a constructor is to ensure that the data members of an object have safe, sensible initial values. Constructors are special member functions that are executed whenever we create new objects of a class type. Constructors have the same name as the class and may not specify a return type. Constructors may be overloaded. Constructors may not be declared as `const`.
    
    ```
    class MyClass {
    public:
        MyClass() : data(0) {} // Default constructor
        MyClass(int val) : data(val) {} // Parameterized constructor
    private:
        int data;
    };
    
    MyClass obj1; // Uses the default constructor
    MyClass obj2(5); // Uses the parameterized constructor
    ```
    
- **Constructor initializer list:** Specifies initial values of the data members of a class. The members are initialized to the values specified in the initializer list before the body of the constructor executes. Class members that are not initialized in the initializer list are implicitly initialized by using their default constructor. Members of class type without a default constructor, and `const` or reference type members must be initialized in the constructor list. Members are initialized in the order of their definitions. Initializers may be any expression. Initializers for data members of class type may call any of its constructors.
    
    ```
    class MemberClass {
    public:
        MemberClass(int val) : value(val) {}
    private:
        int value;
    };
    
    class MyClass {
    public:
        MyClass(int d, int m_val, int& r) : data(d), member(m_val), ref(r), constant(10) {}
    private:
        int data;
        MemberClass member;
        int& ref;
        const int constant;
    };
    
    int main() {
        int x = 5;
        MyClass obj(1, 2, x);
        return 0;
    }
    ```
    
- **Default constructor:** The constructor that is used when no initializer is specified.
    
    - **Synthesized default constructor:** The default constructor created (synthesized) by the compiler for classes that do not define any constructors. This constructor initializes members of class type by running that class's default constructor; members of built-in type are uninitialized.
    - A common mistake when trying to use the default constructor is `MyClass myobj();` which defines a function, not an object. The correct way is `MyClass myobj;`.
    
    ```
    class ClassWithDefault {
    public:
        int value; // Built-in type, uninitialized by synthesized default constructor
        std::string text; // Class type, initialized by std::string's default constructor
    };
    
    ClassWithDefault obj1; // Uses the synthesized default constructor
    std::cout << obj1.value << std::endl; // Might print garbage
    std::cout << obj1.text << std::endl; // Will print an empty string
    
    class ClassWithDefinedDefault {
    public:
        ClassWithDefinedDefault() : data(0) {}
    private:
        int data;
    };
    
    ClassWithDefinedDefault obj2; // Uses the defined default constructor
    ```
    
- **Conversion constructor:** A non-`explicit` constructor that can be called with a single argument. A conversion constructor is used implicitly to convert from the argument's type to the class type.
    
    ```
    class MyClass {
    public:
        MyClass(const std::string& s) : data(s) {} // Conversion constructor
        void print() const { std::cout << data << std::endl; }
    private:
        std::string data;
    };
    
    void process(const MyClass& obj) {
        obj.print();
    }
    
    int main() {
        process("hello"); // Implicit conversion from std::string to MyClass
        MyClass obj = "world"; // Implicit conversion during initialization
        obj.print();
        return 0;
    }
    ```
    
- **`explicit` constructor:** A constructor that can be called with a single argument but that may not be used to perform an implicit conversion. A constructor is made `explicit` by prepending the keyword `explicit` to its declaration.
    
    ```
    class MyClass {
    public:
        explicit MyClass(const std::string& s) : data(s) {} // Explicit constructor
        void print() const { std::cout << data << std::endl; }
    private:
        std::string data;
    };
    
    void process(const MyClass& obj) {
        obj.print();
    }
    
    int main() {
        // process("hello"); // Error: no implicit conversion from std::string to MyClass
        process(MyClass("hello")); // Explicitly creating a MyClass object
        MyClass obj("world"); // Direct initialization is allowed
        // MyClass obj = "world"; // Error: no implicit conversion
        obj.print();
        return 0;
    }
    ```
    
- **Copy constructor:** A constructor that initialises a new object as a copy of another object of the same type. The copy constructor is applied implicitly to pass objects to/from a function by value. The copy constructor is used to explicitly or implicitly initialise one object from another of the same type, copy an object to pass it as an argument to a function, copy an object to return it from a function, initialise the elements in a sequential container, and initialise elements in an array from a list of element initialisers. If we do not define the copy constructor, the compiler synthesises one for us.
    
    ```
    class MyClass {
    public:
        MyClass(int val) : data(val) {}
        MyClass(const MyClass& other) : data(other.data) { // Copy constructor
            std::cout << "Copy constructor called" << std::endl;
        }
        int getData() const { return data; }
    private:
        int data;
    };
    
    MyClass func(MyClass obj) { // Object passed by value (copy constructor called)
        return obj; // Object returned by value (copy constructor called)
    }
    
    int main() {
        MyClass obj1(10);
        MyClass obj2 = obj1; // Copy constructor called
        MyClass obj3(obj1); // Copy constructor called
        MyClass obj4 = func(obj1); // Copy constructor called on passing and returning
        std::cout << obj2.getData() << std::endl;
        return 0;
    }
    ```
    
- **Synthesized copy constructor:** The copy constructor created (synthesized) by the compiler for classes that do not explicitly define the copy constructor. The synthesized copy constructor memberwise initialises the new object from the existing one.
    
- **Memberwise initialisation:** Term used to describe how the synthesized copy constructor works. The constructor copies, member by member, from the old object to the new. Members of built-in or compound type are copied directly. Those that are of class type are copied by using the member's copy constructor. To prevent copies, a class must explicitly declare its copy constructor as private.
    
    ```
    class Member {
    public:
        Member(int val) : value(val) {}
        int value;
    };
    
    class MyClass {
    public:
        int data;
        Member member;
    };
    
    int main() {
        MyClass obj1 = {5, Member(10)};
        MyClass obj2 = obj1; // Synthesized copy constructor performs memberwise copy
        obj2.data = 15;
        obj2.member.value = 20;
        std::cout << obj1.data << " " << obj1.member.value << std::endl; // Output: 5 10
        std::cout << obj2.data << " " << obj2.member.value << std::endl; // Output: 15 20
        return 0;
    }
    ```
    
- **Assignment operator:** The assignment operator can be overloaded to define what it means to assign one object of a class type to another of the same type. The assignment operator must be a member of its class and should return a reference to its object. The compiler synthesises the assignment operator if the class does not explicitly define one.
    
    ```
    class MyClass {
    public:
        MyClass(int val) : data(val) {}
        MyClass& operator=(const MyClass& rhs) { // Overloaded assignment operator
            if (this != &rhs) {
                data = rhs.data;
            }
            return *this;
        }
        int getData() const { return data; }
    private:
        int data;
    };
    
    int main() {
        MyClass obj1(10);
        MyClass obj2(20);
        obj1 = obj2; // Assignment operator called
        std::cout << obj1.getData() << std::endl; // Output: 20
        return 0;
    }
    ```
    
- **Synthesized assignment operator:** A version of the assignment operator created (synthesized) by the compiler for classes that do not explicitly define one. The synthesized assignment operator memberwise assigns the right-hand operand to the left.
    
- **Memberwise assignment:** Term used to describe how the synthesized assignment operator works. The assignment operator assigns, member by member, from the old object to the new. Members of built-in or compound type are assigned directly. Those that are of class type are assigned by using the member's assignment operator.
    
    ```
    class Member {
    public:
        Member(int val) : value(val) {}
        int value;
    };
    
    class MyClass {
    public:
        int data;
        Member member;
    };
    
    int main() {
        MyClass obj1 = {5, Member(10)};
        MyClass obj2 = {15, Member(20)};
        obj1 = obj2; // Synthesized assignment operator performs memberwise assignment
        std::cout << obj1.data << " " << obj1.member.value << std::endl; // Output: 15 20
        return 0;
    }
    ```
    
- **Destructor:** A special member function that cleans up an object when the object goes out of scope or is deleted. The compiler automatically destroys each member. Members of class type are destroyed by invoking their destructor; no explicit work is done to destroy members of built-in or compound type. In particular, the object pointed to by a pointer member is not deleted by the automatic work done by the destructor. Destructors have the same name as the class prefixed with a tilde (`~`), take no parameters, and have no return type.
    
    ```
    class MyClass {
    public:
        MyClass() { resource = new int; }
        ~MyClass() { // Destructor
            delete[] resource;
            std::cout << "Destructor called" << std::endl;
        }
    private:
        int* resource;
    };
    
    void func() {
        MyClass obj; // Constructor called when obj is created
    } // Destructor called when obj goes out of scope
    
    int main() {
        func();
        return 0;
    }
    ```
    
- **Overloaded operator:** A function that redefines one of the C++ operators to operate on object(s) of class type. Overloaded operators must have an operand of class type. This rule enforces the requirement that an overloaded operator may not redefine the meaning of the operators when applied to objects of built-in types. Precedence and associativity are fixed; short-circuit evaluation is not preserved. Overloaded functions that are members of a class may appear to have one less parameter than the number of operands (due to the implicit `this` pointer). Operators `=`, `[]`, `()`, `->` must be defined as members. Compound assignment operators ordinarily ought to be members of the class. Symmetric operators, such as the arithmetic, equality, relational, and bitwise operators are best defined as ordinary nonmember functions. Input and output operators must be nonmember functions.
    
    ```
    class MyClass {
    public:
        MyClass(int val) : data(val) {}
        MyClass operator+(const MyClass& rhs) const { // Overloaded + operator (non-member)
            return MyClass(data + rhs.data);
        }
        MyClass& operator+=(const MyClass& rhs) { // Overloaded += operator (member)
            data += rhs.data;
            return *this;
        }
        bool operator==(const MyClass& rhs) const { // Overloaded == operator (non-member)
            return data == rhs.data;
        }
        friend std::ostream& operator<<(std::ostream& os, const MyClass& obj); // Overloaded <<
    private:
        int data;
    };
    
    std::ostream& operator<<(std::ostream& os, const MyClass& obj) {
        os << obj.data;
        return os;
    }
    
    int main() {
        MyClass obj1(5);
        MyClass obj2(10);
        MyClass obj3 = obj1 + obj2; // Uses overloaded +
        obj1 += obj2; // Uses overloaded +=
        if (obj1 == obj3) { // Uses overloaded ==
            std::cout << "Objects are equal" << std::endl;
        }
        std::cout << obj3 << std::endl; // Uses overloaded <<
        return 0;
    }
    ```
    
- **Conversion operator:** Conversion operators are member functions that define conversions from the class type to another type. Conversion operators must be a member of their class. They do not specify a return type and take no parameters. They return a value of the type of the conversion operator.
    
    ```
    class MyClass {
    public:
        MyClass(int val) : data(val) {}
        operator int() const { // Conversion operator to int
            return data;
        }
        operator bool() const { // Conversion operator to bool
            return data != 0;
        }
    private:
        int data;
    };
    
    void processInt(int val) { std::cout << "Integer: " << val << std::endl; }
    void processBool(bool val) { std::cout << "Boolean: " << val << std::endl; }
    
    int main() {
        MyClass obj(15);
        processInt(obj); // Implicit conversion to int
        if (obj) { // Implicit conversion to bool
            processBool(obj);
        }
        int value = static_cast<int>(obj) + 5; // Explicit conversion to int
        std::cout << "Value: " << value << std::endl;
        return 0;
    }
    ```
    
- **Static member:** A data or function member that is not a part of any object but is shared by all objects of a given class. The name of a static member is in the scope of the class, thereby avoiding name collisions with members of other classes or global objects. Encapsulation can be forced since a static member can be private, a global object cannot. It is easy to see by reading the program that a static member is associated with a particular class. This visibility clarifies the programmer’s intention. Static member functions have no `this` pointer. Static data members must be defined outside the class definition.
    
    ```
    class MyClass {
    public:
        MyClass() { ++objectCount; }
        ~MyClass() { --objectCount; }
        static int getObjectCount() { return objectCount; }
    private:
        static int objectCount; // Static data member declaration
    };
    
    int MyClass::objectCount = 0; // Definition of the static data member
    
    int main() {
        std::cout << "Initial count: " << MyClass::getObjectCount() << std::endl;
        MyClass obj1;
        std::cout << "Count after obj1: " << MyClass::getObjectCount() << std::endl;
        MyClass obj2;
        std::cout << "Count after obj2: " << obj2.getObjectCount() << std::endl; // Can be accessed through an object
        return 0;
    }
    ```
    
- **Friend:** A mechanism by which a class grants access to its nonpublic members. Both classes and functions may be named as friends. Friends have the same access rights as members. A friend declaration introduces the named class or nonmember function into the surrounding scope. A friend function may be defined inside the class, then the scope of the function is exported to the scope enclosing the class definition.
    
    ```
    class MyClass {
    private:
        int data;
        friend void friendFunction(const MyClass& obj); // Friend function declaration
        friend class FriendClass; // Friend class declaration
    public:
        MyClass(int val) : data(val) {}
    };
    
    void friendFunction(const MyClass& obj) {
        std::cout << "Friend function accessing private data: " << obj.data << std::endl;
    }
    
    class FriendClass {
    public:
        void accessPrivate(const MyClass& obj) {
            std::cout << "Friend class accessing private data: " << obj.data << std::endl;
        }
    };
    
    int main() {
        MyClass obj(25);
        friendFunction(obj);
        FriendClass fc;
        fc.accessPrivate(obj);
        return 0;
    }
    ```